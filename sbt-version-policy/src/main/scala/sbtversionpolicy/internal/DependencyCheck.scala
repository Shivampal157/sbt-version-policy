package sbtversionpolicy.internal

import coursier.version.{ModuleMatchers, VersionCompatibility}
import sbt.{Compile, Runtime}
import sbt.librarymanagement._
import sbt.util.Logger
import sbtversionpolicy.DependencyCheckReport

object DependencyCheck {

  private[sbtversionpolicy] def modulesOf(
    report: ConfigurationReport,
    excludedModules: Set[(String, String)],
    scalaVersion: String,
    scalaBinaryVersion: String,
    moduleToVersion: PartialFunction[ModuleID, String],
    log: Logger
  ): Map[(String, String), String] =
    report
      .modules
      .filterNot(_.evicted)
      .map(_.module)
      .filter(module => !excludedModules.contains(module.organization -> module.name))
      .map { mod =>
        val name =
          CrossVersion(mod.crossVersion, scalaVersion, scalaBinaryVersion)
            .fold(mod.name)(_(mod.name))
        (mod.organization, name) ->
          moduleToVersion.applyOrElse(mod, (m: ModuleID) => m.revision)
      }
      .groupBy(_._1)
      .map {
        case (orgName @ (org, name), grouped) =>
          val versions = grouped.map(_._2).distinct
          if (versions.lengthCompare(1) > 0)
            log.warn(s"Found several versions for $org:$name: ${versions.mkString(", ")}")
          (orgName, versions.head)
      }

  private[sbtversionpolicy] def report(
    excludedModules: Set[(String, String)],
    currentDependencies: Map[(String, String), String],
    previousModuleId: ModuleID,
    reconciliations: Seq[(ModuleMatchers, VersionCompatibility)],
    defaultReconciliation: VersionCompatibility,
    sv: String,
    sbv: String,
    depRes: DependencyResolution,
    scalaModuleInf: Option[ScalaModuleInfo],
    updateConfig: UpdateConfiguration,
    warningConfig: UnresolvedWarningConfiguration,
    moduleToVersion: PartialFunction[ModuleID, String],
    log: Logger
  ): DependencyCheckReport = {

    val previousModuleId0 =
      previousModuleId
        .withName(
          CrossVersion(previousModuleId.crossVersion, sv, sbv)
            .fold(previousModuleId.name)(_(previousModuleId.name))
        )
        .withCrossVersion(CrossVersion.disabled)
        .withExplicitArtifacts(Vector.empty)

    val mod =
      depRes.moduleDescriptor(
        ModuleID("dummy-org", "dummy-name", "1.0"),
        Vector(previousModuleId0),
        scalaModuleInf
      )

    val previousReport =
      depRes.update(mod, updateConfig, warningConfig, log)
        .fold(thing => throw thing.resolveException, identity)

    val previousDependencies =
  Seq(
    previousReport.configuration(Compile),
    previousReport.configuration(Runtime)
  ).flatten
    .flatMap { conf =>
      modulesOf(conf, excludedModules, sv, sbv, moduleToVersion, log)
    }
    .filter {
      case ((org, name), _) =>
        org != previousModuleId0.organization || name != previousModuleId0.name
    }
    .toMap   

    DependencyCheckReport(
      currentDependencies,
      previousDependencies,
      reconciliations,
      defaultReconciliation
    )
  }
}